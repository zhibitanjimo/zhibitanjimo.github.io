<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9x9 Puzzle Game</title>
    <style>
        .orgin {
            width: 300px;
            height: 300px;
            overflow: hidden;
            position: relative;
        }
        .orgin img {
            width: 100%;
            height: auto;
            display: block;
        }

        ul.stage {
            margin: 0;
            padding: 0;
            list-style: none;
            background-color: rgb(240, 240, 240);
            position: relative;
            width: 300px;
            height: 300px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
        }
        ul.stage li {
            width: 32px;
            height: 32px;
            overflow: hidden;
            position: relative;
            margin: 1px;
            transition: all 0.3s;
            border-radius: 5px;
        }
        ul.stage li.active {
            box-shadow: 0 0 8px 0 #ff0000;
        }
        ul.stage li img {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div class="orgin">
        <img src="./上课代码/1008(1)/banner1.jpg" alt="Original Image" />
    </div>

    <ul class="stage" id="puzzleStage">
        <!-- Puzzle tiles will be generated by JavaScript -->
    </ul>

    <button onclick="shufflePuzzle()">Shuffle</button>

    <script>
        const puzzleStage = document.getElementById('puzzleStage');
        const gridSize = 9;
        let tiles = [];
        let emptyTile = null;

        function initPuzzle() {
            const imageSrcs = [...new Array(81)].map((_, i) => `./上课代码/1008(1)/banner1.jpg`); // Ensure you have 81 image files

            for (let i = 0; i < gridSize * gridSize; i++) {
                const li = document.createElement('li');
                const img = document.createElement('img');
                img.src = imageSrcs[i];
                li.appendChild(img);
                puzzleStage.appendChild(li);
                tiles.push(li);
            }

            emptyTile = tiles.pop(); // Take the last tile as the empty space
            puzzleStage.appendChild(emptyTile);
            emptyTile.classList.add('empty');
            emptyTile.style.gridColumn = `${Math.floor(tiles.length / gridSize) + 1}`;
            emptyTile.style.gridRow = `${Math.ceil(tiles.length / gridSize) + 1}`;
        }

        function shufflePuzzle() {
            tiles.sort(() => Math.random() - 0.5);
            let emptyIndex = Math.floor(Math.random() * tiles.length);

            // Re-append the tiles to the stage in the new order
            tiles.forEach((tile, index) => {
                tile.style.gridColumn = `${(index + (index === emptyIndex ? 1 : 0)) % gridSize + 1}`;
                tile.style.gridRow = `${Math.floor((index + (index === emptyIndex ? 1 : 0)) / gridSize) + 1}`;
                puzzleStage.appendChild(tile);
            });

            emptyTile = tiles[emptyIndex];
            emptyTile.classList.add('empty');
        }

        puzzleStage.addEventListener('click', (event) => {
            const clickedTile = event.target.closest('li');

            if (!clickedTile || clickedTile.classList.contains('empty')) return;

            const clickedTilePosition = getTilePosition(clickedTile);
            const emptyTilePosition = getTilePosition(emptyTile);

            if ((Math.abs(clickedTilePosition.col - emptyTilePosition.col) === 1 && clickedTilePosition.row === emptyTilePosition.row) ||
                (clickedTilePosition.col === emptyTilePosition.col && Math.abs(clickedTilePosition.row - emptyTilePosition.row) === 1)) {
                swapTiles(clickedTile, emptyTile);
            }
        });

        function swapTiles(tile1, tile2) {
            const tile1Rect = tile1.getBoundingClientRect();
            const tile2Rect = tile2.getBoundingClientRect();

            // Swap positions
            tile1.style.gridColumn = `${tile2Rect.left / 32 + 1}`;
            tile1.style.gridRow = `${tile2Rect.top / 32 + 1}`;
            tile2.style.gridColumn = `${tile1Rect.left / 32 + 1}`;
            tile2.style.gridRow = `${tile1Rect.top / 32 + 1}`;

            // Add active class for visual feedback
            tile1.classList.add('active');
            tile2.classList.add('active');

            setTimeout(() => {
                tile1.classList.remove('active');
                tile2.classList.remove('active');
            }, 300);
        }

        function getTilePosition(tile) {
            const rect = tile.getBoundingClientRect();
            return {
                col: rect.left / 32 + 1,
                row: rect.top / 32 + 1
            };
        }

        // Initialize the puzzle
        initPuzzle();
    </script>
</body>
</html>